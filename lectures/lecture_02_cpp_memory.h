--
Продвинутый С++ (Память, указатели, массивы, передача по ссылке)


1. Передача по ссылке/по значению

Передача по значению

void func(int a, int b) {
	a = 5;
	b = 7;
}

void func(int a, int b) {
	//
	int local_a = a;
	int local_b = b;
	//
	local_a = 5;
	local_b = 7;
}

Ex:
int a = 1,b = 1;
func(a,b);

// a == ?, b == ?


----

Передача по ссылке

void func(int & a, int & b) {
	a = 5;
	b = 6;
}

Ex:
int var1 = 3, var2 = 4;

func(var2,var1);

// var1 == 6, var2 == 5

----

Память:

1. Код программы
2. Стек
3. Куча (Heap, динамическая память)

----

Указатели

<type> * <name>;

int * p;
int ** p;
int *** p;

Основная цель: указывать на область памяти

----

Операции с указателями

1. Взятие адреса

int a = 7;


int * p = &a; // взятие адреса возвращает адрес типа тип *


2. Разыменование

int a = 7;

int * p = &a;

int b = *p;

3. Арифметика указателей

Сложение

int * p1;
char * p2;
p1 = p1 + 1; // сдвиг на sizeof(int)
p2 = p2 + 1;

Вычитание аналогично сложению

4. void *

5. NULL

При попытке разыменования нулевого указателя будет краш.

----

Работа с памятью

1. new и new []

int * p1 = new int;
int * p2 = new int[15];

2. delete и delete []

delete p1;

delete [] p2;

----

Массивы

Это указатели.

int a[10];

int * p = a; // &a[0]
p++;


*(a + 4);
*(4 + a);

a[i];
i[a];

----

int * p2 = new int[15];

----

int a[10] = { 1, 3, 6, 7, -1, 6, 56, 70, 1, 34 };

int func(int * p) {
	int * q = p + 5;
	return *q + *(p+3) + *p
}

int main() {
	
	std::cout << func(a + 3) << std::endl;
	
	return 1;
}

----

p = a + 3 *= 7
p + 5 = a + 8 *= 1
p + 3 = a + 6 *= 56

----

int array[10];
int * p = array + 4;

int array2d[10][10];

----

int n;
std::cin >> n;

int ** array = new int*[n];

for(int i = 0; i < n; ++i) {
	array[i] = new int[n];
}

for(int i = 0; i < n; ++i) {
	delete [] array[i];
}

delete [] array;

----

Практическое применение

1. Передача сложных структур

int field[10][10];

void print() {
	for(blabalbal)
		for(blabalbla)
			вывести
}

void print(int ** a) {
	for(int i = 0; i < 10; ++i) {
		for(int j = 0; j < 10; ++j) {
			std::cout << a[i][j];
		}
		std::cout << std::endl;
	}
}

----

Структуры

struct person {
	int age;
	char name[10];
	bool is_master;
};


person student;


student.age = 45;
strcpy(student.name,"Mr.Freeman");
student.is_master = true;

----

Задача:

1. Допилить морской бой дружеской команды
2. Убрать весь копипаст функций для своего и вражеского массива, сделать одну функцию, принимающую на вход массив
3. Разбить всё на структуры

----

Задача:

1. Крестики-нолики на поле [n][n]

* Играют двое игроков
* Если выстроили пять в ряд или по диагонали — победа

----

РПГ

1. Есть отряд героев и отряд монстров
2. Герой и монстр дерутся один на один
3. Во время боя они обмениваются ударами, пока один из них не умрёт
4. После поражения идёт схватка между новым героем/монстром и выжившим
5. Герой и монстр имеют следующие характеристики
* Здоровье
* Атака

(+) Реализовать геймпленые элементы (защита? выбор, куда ударить?)
(+) Прокачка